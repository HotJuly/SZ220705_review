1.props
	适用场景:父子组件

	父向子流程:
		1.父组件在组件的标签上,添加标签属性,并将想要传递的数据作为标签属性值书写
		2.子组件在自己的配置对象中,添加props配置选项,并在内部声明自己想要接收的标签属性名

		父向子传递数据的时候,父组件给的是数据

	子向父流程:
		1.父组件在子组件标签上,添加标签属性,并将接收数据的函数作为标签属性值书写
			注意点:传递的函数,必须声明在父组件的methods中
				因为methods中的函数,this都会被Vue使用bind方法,强行修改成当前组件实例对象

		2.子组件在自己的配置对象中,添加props配置选项,并在内部声明自己想要接收的标签属性名

		3.子组件调用接收到的函数,并给该函数传入实参

		4.函数内部代码被执行,此时可以将得到的数据,通过this,传入父组件的data中

		子向父传递数据的时候,父组件给的是函数


2.provide/inject
	适用场景:祖孙组件
	使用流程:
		1.祖先组件的配置对象中,添加provide属性,属性值可以是对象或者函数
			注意:如果想要将当前组件的某个data数据暴露出去,必须写成函数形式,对象形式不行

		2.后代组件的配置对象中,添加inject属性,属性值是数组
			数组内部书写需要接收的属性名称即可

	注意:
		provide暴露的数据本身就不是响应式的,这是Vue故意的
			如果想要具有响应式效果,我们可以将暴露出的对象变成响应式,再暴露


3.自定义事件
	适用场景:子向父传参
	原生事件
		就是一阶段所学习的DOM事件,
			每个DOM节点上,具有哪些事件,都是W3C机构指定的
			这些事件的触发,都是浏览器负责的

	自定义事件
		在学习Vue之后出现的新的事件
			自定义事件的名称,是由开发者自己随意订制
			这些事件的触发,都是开发者自己调用触发

	事件类型的区分:绑定在原生DOM节点上的就是原生事件,绑定在组件身上的就是自定义事件
		如果在组件上绑定事件的时候,写上.native,那么该事件就会变成原生事件,并绑定在组件的根节点上

	基础API:
		1.$on	->	给某个组件实例绑定自定义事件以及相关的事件处理器
		2.$once	->	给某个组件实例绑定自定义事件以及相关的事件处理器,但是只能触发一次,触发之后会自动解绑
		3.$emit	->	可以触发某个组件实例身上的某种事件,从而导致对应的事件处理器会被执行
		$.$off		->	可以用户解绑某个组件实例身上的事件
				1.什么都不传->解绑当前组件实例身上,所有的事件和事件处理器
				2.只传一个参数->解绑当前组件实例身上,对应的事件以及他所有的事件处理器
				3.如果传入2个参数->解绑当前组件身上,对应事件中的对应的事件处理器

	v-model(双向数据绑定)
		对input框使用
			效果:
				1.将data中的数据,作为input框的默认值进行展示(属性名:value)
    					<input type="text" :value="msg1"/>

				2.当用户修改input框中的内容时,会自动修改data中对应的属性值(事件名:input)
    					<input type="text" :value="msg1" @input="event=>msg1=event.target.value"/>

		对组件标签使用				
				1.将data中的数据,作为标签属性向下传递给子组件(属性名:value)
    					<HelloWorld :value="msg1"/>

				2.给子组件绑定事件input,子组件可以触发该事件,用于修改父组件对应的状态数据(事件名:input)
    					<HelloWorld :value="msg1" @input="data=>msg1=data"/>

			注意:可以在子组件使用model配置选项,自定义v-model传下来的属性名和事件名

	.sync修饰符				
		1.将data中的数据,作为标签属性向下传递给子组件(属性名自定义)
    			<HelloWorld :msg="msg1"/>

		2.给子组件绑定事件,子组件可以触发该事件,用于修改父组件对应的状态数据(事件名->update:属性名)
			<HelloWorld :msg="msg1" @update:msg="data=>msg1=data"/>

		注意:在Vue3中,.sync修饰符和v-model实现了二合一效果,表面上还是v-model,实际内部是.sync的内核

	全局事件总线
		角色
			订阅者->订阅者是代表当前这个人想要接收数据
			发布者->发布者是代表当前这个人具有数据,想要将该数据给别人

		操作
			1.订阅
			2.发布
			3.解绑

		约束:
			1.订阅者和发布者必须同时存在
			2.订阅操作必须在发布之前

		流程:
			1.创建事件总线对象,并将其放在Vue的原型对象身上
				Vue.prototype.$bus = new Vue();

			2.在订阅方组件中,使用$on方法订阅消息
    				this.$bus.$on('sendData',(data)=>{
      					console.log('sendData',data)
   				 })

			3.在发布方组件中,使用$emit方法发布数据
    				this.$bus.$emit('sendData',678)

		

4.找到对应的组件实例对象
	$parent->获取到父组件的组件实例对象,也就是父组件代码中的this
	$root->获取到当前项目的根组件实例对象,就是main.js中的new Vue
	$children->获取到由子组件实例对象组成的数组
		注意:$children 并不保证顺序，也不是响应式的
			所谓的不能保证顺序,是因为组件中有可能出现异步组件的情况,如果没有,排列顺序与书写顺序相同
			所谓的不是响应式的,是指修改该数组中的排列顺序,不会影响到页面上的显示顺序
	$refs->获取到指定的内容
		对原生标签使用ref属性
			可以获取到对应标签的真实DOM

		对组件标签使用ref属性
			可以获取到组件实例对象

5.$attrs和$listeners
	$attrs->可以收集到由父组件传递下来的标签属性中,props没有接收的部分
		数据类型:对象
			会将标签属性名作为自己的属性名,标签属性值作为自己的属性值存放
			就是个垃圾桶

		v-bind指令可以接收一个对象
			他会将该对象进行解构处理,内部的属性名会变成标签的属性名,属性值会成为标签的属性值
			只要给他一个对象就可以,对于对象没有特殊要求,不一定非要配合$attrs使用

	$listeners->可以收集到当前组件身上的自定义事件
		数据类型:对象
			会将自定义事件的名称作为自己的属性名,自定义事件的回调函数作为属性值存放

		v-on指令可以接收一个对象
			他会将对象进行解构处理,内部的属性名会成为事件名称,属性值作为事件的回调函数绑定			
			只要给他一个对象就可以,对于对象没有特殊要求,不一定非要配合$listeners使用

6.插槽
	目的是用来传递一段页面结构给某个组件使用
	1.默认插槽
		1.父组件在子组件的成对标签中,传入一段页面结构
		2.子组件在自己的template中,使用slot组件,告知需要显示插槽结构的位置

	2.具名插槽		
		1.父组件在子组件的成对标签中,传入一段页面结构
		2.父组件需要使用v-slot指令,给当前这段插槽结构取名
		3.子组件在自己的template中,使用slot组件,告知需要显示插槽结构的位置
		4.在slot标签上,需要添加name属性,属性值要与v-slot取得名字相同

	3.作用域插槽		
		1.父组件在子组件的成对标签中,传入一段页面结构
		2.父组件需要使用v-slot指令,给当前这段插槽结构取名
		3.子组件在自己的template中,使用slot组件,告知需要显示插槽结构的位置
		4.在slot标签上,需要添加name属性,属性值要与v-slot取得名字相同
		5.子组件将自己需要传递的数据,通过标签属性的形式,写在slot组件身上
		6.在插槽结构中,v-slot指令之后,写上="变量名",那么该变量中就会存储一个对象,这个对象会收集slot上的标签属性以及对应的属性值

		注意:即便是作用域插槽,也是有父向子传参,没有子向父传参

7.路由传参

8.Vuex












	