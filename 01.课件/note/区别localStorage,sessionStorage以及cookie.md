# 区别localStorage,sessionStorage以及cookie

1. 生命周期
   1. cookie
      1. 如果设置max-age属性,只要不超过max-age所写的时间限制,存储的数据就会一直存在
      2. 如果不设置max-age属性,如果没有该属性,那么当前cookie就是**会话级cookie**,也就是只要关闭当前标签页或者浏览器,那么数据就会丢失
   2. localStorage(持久化存储)
      1. 只要存入localStorage数据,只要不主动删除,那么数据将会永久存在
   3. sessionStorage(会话存储)
      1. 存入sessionStorage数据,如果关闭当前标签页或者关闭浏览器,那么数据就会丢失
      2. 注意:**刷新标签页,不会导致sessionStorage存储的数据丢失**
2. 存储位置
   1. cookie
      1. 如果设置max-age属性,存储于硬盘中
      2. 如果不设置max-age属性,存储于内存中
   2. localStorage(持久化存储)
      1. 存储于硬盘中
   3. sessionStorage(会话存储)
      1. 存储于内存中
3. 存储大小
   1. cookie->4KB
   2. localStorage(持久化存储)->一般是5MB,垃圾IE是3012KB
   3. sessionStorage(会话存储)->一般是5MB,垃圾IE是3012KB
4. 作用范围
   1. cookie
      1. cookie的作用范围与两个属性有关
      2. domain属性
         1. 例如=>domain=".baidu.com"
         2. 如果domain属性如上,那么当前cookie就可以在baidu.com以及他的后代域名中访问
      3. path属性
         1. 例如=>path="/a"
         2. 如果path属性如上,那么当前cookie就可以在/a以及他的后代路由中访问
      4. 总结:**儿子可以使用父亲的,父亲不能使用儿子的**
   2. localStorage(持久化存储)
      1. 与域名相关,只有相同的域名才能访问对应的数据
      2. 可以在其他的标签页中,查看/使用/修改该数据,多个标签页会**共享一份**localStorage的数据
   3. sessionStorage(会话存储)
      1. 与域名相关,只有相同的域名才能访问对应的数据
      2. **无法在多个标签页中共享sessionStorage中的数据**
5. 与服务器之间的关系
   1. cookie(被借用的本地存储)
      1. cookie是服务器创建,浏览器存储
      2. 服务器如果想将cookie数据传给前端,会在响应头中添加属性set-Cookie,实现数据传递
      3. 浏览器想要将cookie数据发给服务器,会在请求头重添加属性Cookie,实现数据传递
      4. 浏览器会自动保存和自动发送cookie
   2. localStorage
      1. 与服务器没有关系
   3. sessionStorage
      1. 与服务器没有关系
6. 使用场景
   1. cookie
      1. 主要是给后端用于分散存储数据,降低服务器的成本
   2. localStorage
      1. 如果当前数据希望下次打开项目,还能继续使用,那么就存储于localStorage中
   3. sessionStorage
      1. 如果当前数据本轮使用项目的时候,还需要用到,那么就存储于sessionStorage中
7. **面试题:请问如何实现跨标签页通信?**
   1. **假设具有两个标签页,A标签页是发送数据的,B标签页是接收数据的**
   2. **方案一:使用localStorage+storage事件实现**
      1. **首先在B页面给window对象,绑定事件监听,事件名称storage,并传入事件回调函数**
      2. **A页面使用localStorage.setItem方法,将数据存入localStorage中**
      3. **B页面的事件回调函数就会触发,在事件对象中可以获取到本次的最新值**
      4. **优点:**
         1. **如果需要传递多次数据,那么只需要调用多次setItem即可**
         2. **传递的数据大小较大,最多可以传递5MB的数据**
      5. **缺点:**
         1. **该方案流程相对复杂一点**
         2. **只能在同域名的情况下传递,如果出现跨域名就无法实现**
   3. **方案二:使用URL进行传参**
      1. **首先在A页面使用window.open方法,将需要传递的数据拼接在跳转的url中**
      2. **B页面显示之后,可以在window.location中获取到对应的URL参数**
      3. **优点:**
         1. **该方法流程最简单**
         2. **可以实现跨域名通信**
      4. **缺点:**
         1. **每次传递的参数有限,URL长度具有限制**
         2. **想要多次传递数据需要进行多次跳转**
   4. **方案三:使用domain属性实现**
      1. **在B页面,使用window.open方法,打开一个全新的页面,此时可以获取到新打开页面的window对象(简称w1)**
      2. **在B页面中,执行document.domain="顶级域名"**
      3. **在A页面中,也执行document.domain="顶级域名"**
      4. **A页面在自己的window对象身上存储数据**
      5. **B页面就可以通过流程1得到的w1对象,获取到对方网页的数据,并且还可以进行修改互通**
      6. **优点:**
         1. **可以跨域名通信**
            1. **但是只适用于同一个域名衍生出来的后代域名中使用**
            2. **如果是两家不同的公司,该方案就无效**
      7. **缺点:**
         1. **流程是最复杂的**