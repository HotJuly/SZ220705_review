<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /*
        闭包
            1.闭包的产生条件
                闭包是一种引用关系
                1.必须具有内外函数嵌套
                2.内部函数必须使用外部函数的变量

                个人认为,闭包分为两种
                    1.有效闭包
                        外部函数被调用的时候,会将内部函数返回出去,那么这个闭包就可以持久保留,称为有效闭包
                    2.无效闭包
                        外部函数被调用的时候,没有将内部函数返回出去,那么这个闭包就会快速销毁,称为无效闭包

            2.闭包的创建时机
                在外部函数被调用的时候,就会产生闭包

            3.闭包的优点
                1.延长局部变量的生命周期
                    外部函数的变量会存储于外部函数的执行上下文中,但是外部函数执行结束的时候,
                        对应的执行上下文会被销毁,会导致存在内部的变量也被销毁
                    但是内部函数还需要继续使用这个外部变量,所以js使用闭包将该变量缓存起来

                2.可以实现js模块化

            4.闭包的缺点
                由于闭包会缓存本该死去的变量,会导致内存无法正常释放,会被继续占用
                内存泄漏
                    在我们平常实现功能的时候,可能付出了更多的内存空间才实现某个功能
                        简单点说就是没有管理好内存,浪费内存了

                内存溢出
                    平常浪费的内存太多了,最终超过了计算机的内存上限,导致程序宕机,无法使用

                内存泄漏我们可以接受,但是内存溢出肯定是不能接受的

            5.如何解决闭包的副作用?
                尽量不要使用闭包
                及时释放不用的闭包
                    问题:为什么闭包不会被释放?
                        由于内部函数还需要使用闭包中的变量,所以闭包不能被释放
                        内部函数因为被外部的变量引用着,所以内部函数不会被释放

                    方法:
                        将存储内部函数的变量值更新,将内部函数的引用进行释放,内部函数被释放,
                            就会导致闭包无人使用,那么闭包也会被释放

                        注意:
                            1.如果内部函数具有多个变量引用他,需要将全部都释放掉才可以
                            2.多个内部函数都是用到外部函数的变量,那么他们会共享一个闭包对象
                                    这个闭包对象中,会存放所有缓存的变量

                                如果多个内部函数都在引用闭包对象,记得要把所有的内部函数都释放掉

                    垃圾回收机制
                        如果一个对象没有人使用/引用它,垃圾回收机制就会将它占用的内存释放(这就是回收)

            6.闭包是什么?
                闭包是一个对象
                    闭包内部会存储需要使用到的变量和他的变量值

                    官方定义:闭包是外部函数的作用域和内部函数的词法环境组合生成的对象
                    简单点说:闭包是外部函数的变量对象和内部函数的代码生成的对象

            7.闭包的使用场景
                函数的防抖/节流
                后台管理系统删除品牌功能




        */
      /*
        执行上下文
            执行上下文中,会存放当前函数中的this指向,return结果,以及变量对象
                变量对象是用来收集当前函数中,声明的所有的变量以及变量值的一个对象

            创建时机:
                在函数调用的时候,就会创建一个全新的执行上下文
                    这个执行上下文会被推入执行栈中,这个过程俗称(入栈)
                    栈使用数组实现的,特点:先进后出,后进先出

            销毁时机:
                在函数调用结束的时候,就会销毁对应的执行上下文
                    这个过程称为出栈

            作用域是一套规则,一套定义(并不是真实存在的东西)
                变量对象就是作用域实现的结果
       
       
       */

      //   function wrap() {
      //     var a = 1;
      //     var b = 2;
      //     function inner() {
      //       console.log("inner", a);
      //     }
      //     // console.log(inner)
      //     return inner;
      //   }
      //   var fn = wrap();
      //   var fn2 = fn;
      //   fn = null;
      //   fn2 = null;

      //   fn();

      //--------------------------------------------
      //   function fn() {
      //     var a = 1;
      //     a++;
      //     console.log(a);
      //   }

      //   fn();
      //   fn();

      //-----------------------------------

      //   function wrap() {
      //     function inner() {
      //       console.log("inner", a);
      //     }
      //     var a = 1;
      //     inner();
      //   }
      //   wrap();

      //-------------------------------
      // var data = 2;
      // var data = 3;

      //   (function () {
      //     var data = 2;

      //     function getData() {
      //       return data;
      //     }

      //     function addData(num) {
      //       //   return data;
      //       data += num;
      //     }

      //     window.fns = {
      //       getData,
      //       addData,
      //     };
      //   })();

      //   var data = 3;

      //   fns.addData(9);
      //   console.log(fns.getData());

      //-----------------------------
        function wrap() {
          var a = 1;

          function inner1() {
            a++;
            console.log("inner", a);
          }

          function inner2() {
            a += 2;
            console.log("inner", a);
          }

          return {
              inner1,
              inner2
          };
        }
        var {inner1,inner2} = wrap();

        inner1();//2
        inner1();//3
        inner1();//4
        inner1();//5

        inner2();//3  7
        inner2();//5  9
        inner2();//7  11
        inner2();//9  13

        inner1 = null;
        inner2();//3 15

        var {inner1,inner2} = wrap();
        inner2();//3 17

      //-----------------------------------------
    //   function wrap() {
    //     var a = 1;
    //     var b = 2;
    //     var c = 3;
    //     var d = 4;

    //     function inner1() {
    //       console.log("inner1", a, b);
    //     }

    //     function inner2() {
    //       console.log("inner2", b, c);
    //     }

    //     return {
    //       inner1,
    //       inner2,
    //     };
    //   }
    //   wrap();
    </script>
  </body>
</html>
